<!-- 
# Building Thermal Simulation — Technical README

**Standard alignment**: ISO 52010-1 (climate/solar), ISO 52016-1 (zone balance), ISO 13789 (transmission & unconditioned zones), ISO 16798-1/-7 (internal gains & natural ventilation)  
**License**: MIT  
**Version**: 0.1  
**Authors**: Daniele Antonucci, Ulrich Filippi Oberegger, Olga Somova

---

## 0. Purpose

This README is a **self-contained technical specification** for the computation chain used by the provided modules:
- `global_inputs.py`
- `generate_profile.py`
- `ventilation.py`

It **details all equations** (with **equation numbers**) and **maps** them to the `BUI` schema you supplied. The focus is on **multi-zone coupling** with **thermally unconditioned adjacent zones**, ventilation conductances, internal gains, and the overall **hourly heat balance** consistent with ISO methods.

> This document uses LaTeX in fenced code blocks so you can render it in any Markdown viewer that supports MathJax/KaTeX.

---

## 1. Input Schema (`BUI`) and Conventions

### 1.1 Root keys
- `building`: meta information for the **main conditioned zone** (height, area, azimuth, etc.).
- `adjacent_zones`: list of **thermally unconditioned zones** adjacent to the main zone.
- `building_surface`: envelope elements of the main zone (opaque/transparent), each with geometry, thermo-physic parameters, and orientation.
- `building_parameters`: setpoints, nominal system capacities, airflows in ACH, internal-gain categories, and schedule profiles.
- `units`: human-friendly descriptions of units present in the data.

### 1.2 Surface targeting
- If `name_adj_zone is None`: the surface is **external (ambient)** or **ground** (when declared as such).
- If `name_adj_zone == 'adj_k'`: the surface is an **interface** between the main zone and the **unconditioned adjacent** zone `adj_k`.

### 1.3 Transparent elements
Transparent surfaces (windows) drive:
- **Transmission to ambient** (`U*A`),  
- **Solar gains** via ISO 52010 irradiances and **g-value**,  
- **Natural ventilation** sizing via effective opening area and stack height.

### 1.4 Adjacent zones arrays
Each unconditioned zone provides arrays:
- `area_facade_elements` (m²)
- `typology_elements` (e.g. `'OP'` opaque, `'GR'` ground)
- `transmittance_U_elements` (W/m²K)
- `orientation_elements` (`'NV','SV','EV','WV','HOR'`)
- plus scalar `volume` (m³), `a_use` (m²), `building_type_class`

These describe **that zone’s own envelope** for the ISO 13789 calculation of its dispersion to ambient.

---

## 2. Symbols and Units

```
θ_z      = indoor air temperature of main zone [°C]
θ_e      = external (ambient) air temperature [°C]
C_z      = lumped heat capacity of main zone [J/K]
U_s      = U-value of surface s [W/m²K]
A_s      = area of surface s [m²]
H        = generic heat transfer coefficient [W/K]
H_ve     = ventilation heat transfer coefficient [W/K]
q_v      = airflow [m³/h]  (rule-of-thumb 0.33*q_v → W/K)
ρ_air    = air density ≈ 1.204 kg/m³ at 20 °C
c_p,air  = specific heat of air ≈ 1006 J/(kg·K)
g        = solar factor of transparent element [-]
E_s      = incident solar irradiance on surface s [W/m²]
n_ue     = air change rate unconditioned→external [h⁻¹]
V        = volume [m³]
```

---

## 3. Zone Energy Balance (ISO 52016-1)

```math
\boxed{
C_z \,\frac{\mathrm{d}\,\theta_z}{\mathrm{d}t}
= \Phi^{\mathrm{sol}}_z
+ \Phi^{\mathrm{int}}_z
+ \sum_{s \in S_{\mathrm{ext}}} U_s A_s (\theta_e - \theta_z)
+ \sum_{j=1}^{N_{ztu}} H_{z \leftrightarrow ztu_j} (\theta_{ztu_j} - \theta_z)
+ H^{\mathrm{ve}}_z (\theta_e - \theta_z)
+ \Phi^{\mathrm{sys}}_z
}
\tag{3.1}
```

Auxiliary **unconditioned** adjacent zone \(ztu\) (quasi-steady node, ISO 13789 abstraction):
```math
0 = H_{ztu \to e}(\theta_e - \theta_{ztu}) + H_{z \leftrightarrow ztu}(\theta_z - \theta_{ztu})
\;\Rightarrow\;
\theta_{ztu} = \frac{H_{ztu \to e}\,\theta_e + H_{z \leftrightarrow ztu}\,\theta_z}{H_{ztu \to e}+H_{z \leftrightarrow ztu}}
\tag{3.2}
```

Elimination of \( \theta_{ztu}\) yields a **single-zone** reduced form (see §5).

---

## 4. Transmission Terms (ISO 13789)

### 4.1 Global decomposition
```math
\boxed{ H_{\mathrm{tr}} = H_d + H_g + H_u + H_a } \tag{4.1}
```
- \(H_d\): exterior envelope (opaque & transparent) of the main zone → \( \sum U_s A_s \).
- \(H_g\): ground (slab/basement). (ISO 13370 can refine; simplified here as \( \sum U_s A_s\) for ground elements.)
- \(H_u\): interfaces to **unconditioned** zones.
- \(H_a\): adjacent buildings (not used unless modeled as unconditioned zones).

### 4.2 Partition from `BUI["building_surface"]`
```math
H_{z\to e} = \sum_{s \in S_{\mathrm{ext}}} U_s A_s,\quad
H_{z \leftrightarrow ztu_k} = \sum_{s \in S_{z \leftrightarrow ztu_k}} U_s A_s,\quad
H_g = \sum_{s \in S_{\mathrm{ground}}} U_s A_s
\tag{4.2}
```

### 4.3 Unconditioned zone dispersions
Define:
- transmission **to ambient** from the unconditioned zone’s own envelope \(H^{\mathrm{tr}}_{ztu \to e}\),
- ventilation **to ambient** \(H^{\mathrm{ve}}_{ztu \to e}\) with \(q_{ue} = V_{ztu}\, n_{ue}\) and rule-of-thumb conversion,
```math
H^{\mathrm{ve}}_{ztu \to e} = 0.33\, q_{ue} = 0.33\, V_{ztu}\, n_{ue} \quad [\mathrm{W/K}]
\tag{4.3}
```
No air exchange towards main zone for worst-case (ISO 13789 guidance): \(q_{iu}=0\Rightarrow H^{\mathrm{ve}}_{z\leftrightarrow ztu}=0\). Hence
```math
H_{ztu \to e} = H^{\mathrm{tr}}_{ztu \to e} + H^{\mathrm{ve}}_{ztu \to e},\quad
H_{z \leftrightarrow ztu} = H^{\mathrm{tr}}_{z \leftrightarrow ztu}
\tag{4.4}
```

### 4.4 Monthly adjustment factor \(b_{ztu,m}\)
```math
\boxed{
b_{ztu,m} = \frac{H_{ztu \to e,m}}{H_{ztu \to e,m}+H_{z \leftrightarrow ztu,m}}
}
\tag{4.5}
```

---

## 5. Reduced Single-Zone Form (with unconditioned zones)

Using (3.2) in (3.1), the interface term becomes \((1-b_{ztu,m})\,H_{z \leftrightarrow ztu,m}(\theta_e-\theta_z)\). Summing all couplings:
```math
\boxed{
C_z \frac{\mathrm{d}\,\theta_z}{\mathrm{d}t}
= \Phi^{\mathrm{sol}}_z + \Phi^{\mathrm{int}}_z
+ \left( H_{z\to e} + \sum_j (1-b_{ztu_j,m}) H_{z \leftrightarrow ztu_j,m} + H_g + H^{\mathrm{ve}}_z \right) (\theta_e - \theta_z)
+ \Phi^{\mathrm{sys}}_z
}
\tag{5.1}
```

Implicit Euler (hourly step \(\Delta t\)) for time layer \(n\to n+1\):
```math
\left(\frac{C_z}{\Delta t} + H^{\mathrm{eff}}_{z\to e,m}\right)\theta_z^{n+1}
= \frac{C_z}{\Delta t}\theta_z^{n}
+ H^{\mathrm{eff}}_{z\to e,m}\,\theta_e^{n+1}
+ \Phi^{\mathrm{sol}}_z{}^{n+1} + \Phi^{\mathrm{int}}_z{}^{n+1} + \Phi^{\mathrm{sys}}_z{}^{n+1}
\tag{5.2}
```
where \(H^{\mathrm{eff}}_{z\to e,m} = H_{z\to e} + \sum_j (1-b_j)H_{z\leftrightarrow j} + H_g + H^{\mathrm{ve}}_z\).

---

## 6. Natural Ventilation (ISO 16798-7, single-sided)

### 6.1 Effective stack height from windows
For each window \(i\) with height \(h_{w,i}\) and parapet height \(h_{\mathrm{parapet},i}\):
```math
h_{w,\mathrm{path},i} = h_{\mathrm{parapet},i} + \frac{h_{w,i}}{2},\quad
h_{w,\mathrm{fa},i} = \frac{h_{w,i}}{2}
\tag{6.1}
```
```math
h_w^{\mathrm{st}} = \max_i \left( h_{w,\mathrm{path},i} + \frac{h_{w,\mathrm{fa},i}}{2} \right)
                   - \min_i \left( h_{w,\mathrm{path},i} - \frac{h_{w,\mathrm{fa},i}}{2} \right)
\tag{6.2}
```

### 6.2 Air densities
With altitude \(H\) (m) and outdoor temperature \(T_e\) (°C):
```math
\rho_{a,\mathrm{ref}}(H) \approx 1.204\left(1-\frac{0.00651\,H}{293}\right)^{4.255},\quad
\rho_{a,e} = \frac{291.15}{273.15 + T_e}\,\rho_{a,\mathrm{ref}}
\tag{6.3}
```

### 6.3 Effective opening area
If window i has maximum open area \(A_{w,i}\) and open fraction \(R_{w,i}\in[0,1]\) then \(A^{\mathrm{eff}}_{w,i}=R_{w,i}A_{w,i}\). If not provided, use \(R_{w,i}=0.9\).
```math
A_w^{\mathrm{tot}} = \sum_i A^{\mathrm{eff}}_{w,i}
\tag{6.4}
```

### 6.4 Airflow and conductance
Coefficients (ISO 16798-7 Table 11): \(C_{\mathrm{wnd}}=0.001\) [1/(m/s)], \(C_{\mathrm{st}}=0.0035\) [(m/s)/(m·K)]. With site wind \(u_{\mathrm{site}}\) (m/s) and \(\Delta T = |θ_z-θ_e|\):
```math
q_v = 3600 \cdot \frac{\rho_{a,\mathrm{ref}}}{\rho_{a,e}} \cdot \frac{A_w^{\mathrm{tot}}}{2}
      \cdot \left( \max\{ C_{\mathrm{wnd}}u_{\mathrm{site}}^2,\; C_{\mathrm{st}}\,h_w^{\mathrm{st}}\,\Delta T \} \right)^{1/2}
\tag{6.5}
```
```math
H^{\mathrm{ve}}_z = \frac{c_{p,\mathrm{air}}\rho_{\mathrm{air}}}{3600}\, q_v \quad [\mathrm{W/K}]
\tag{6.6}
```

### 6.5 Occupancy-based simplified mode
If `type_ventilation="occupancy"` and per-area flow \(f_p\) [L/(s·m²)] with useful area \(A_{\mathrm{use}}\):
```math
q_v = A_{\mathrm{use}}\,(3.6\,f_p)\quad [\mathrm{m^3/h}],\qquad
H^{\mathrm{ve}}_z = \frac{c_{p,\mathrm{air}}\rho_{\mathrm{air}}}{3600}\, q_v
\tag{6.7}
```

---

## 7. Internal Gains (ISO 16798-1 families)

Let the **full-load** densities be \(q_{\mathrm{occ}}, q_{\mathrm{app}}, q_{\mathrm{light}}\) [W/m²] and let **profiles** be \(h_{\mathrm{occ}}(t), h_{\mathrm{app}}(t), h_{\mathrm{light}}(t)\in[0,1]\). For useful area \(A_{\mathrm{use}}\):
```math
\boxed{
\Phi^{\mathrm{int}}_z(t) =
\left(q_{\mathrm{occ}}h_{\mathrm{occ}}(t) + q_{\mathrm{app}}h_{\mathrm{app}}(t) + q_{\mathrm{light}}h_{\mathrm{light}}(t)\right)\,A_{\mathrm{use}}
}
\tag{7.1}
```

If a portion of direct gains is assumed to **spill into unconditioned zones** and partially return (conductively) according to the monthly factors \(b_{ztu,m}\) and distribution \(F_{ztc\to ztu,m}\):
```math
\Phi^{\mathrm{int}}_z(t) \leftarrow \Phi^{\mathrm{int,dir}}_z(t)
+ \sum_j (1-b_{ztu_j,m})\,F_{ztc\to ztu_j,m}\,\Phi^{\mathrm{int,dir}}_z(t)
\tag{7.2}
```

---

## 8. Profiles and Calendars (`generate_profile.py`)

The generator creates a 13-month hourly DataFrame with flags:
- `is_holiday`, `is_weekend`, `is_working_day` (via `holidays` library)
- per-category profiles mapped hour-wise:
```math
p_c(t) =
\begin{cases}
p_{c,\mathrm{wd}}(h(t)) & \text{if working day} \\[2pt]
p_{c,\mathrm{hd}}(h(t)) & \text{otherwise}
\end{cases}
\tag{8.1}
```

You can pass a dict of category arrays or pairs `(weekday, holiday)`; any missing category uses the default pair.

---

## 9. Solar Gains (ISO 52010-1, summary)

For transparent element \(w\) with area \(A_w\), solar factor \(g_w\) and incident irradiance \(E_w(t)\) (from ISO 52010 projections including view factors and shading if enabled):
```math
\Phi^{\mathrm{sol}}_{w}(t) = g_w\, A_w\, E_w(t)
\tag{9.1}
```
Opaque solar absorption can be accounted via `solar_absorptance` into surface energy balance when needed.

---

## 10. Assembly Algorithm (Multi-Zone with Unconditioned Adjacent Zones)

**Preprocessing (time-invariant):**
1. From `BUI["building_surface"]`:
   - Accumulate \(H_{z\to e} = \sum_{\text{ext}} U A\)
   - Accumulate \(H_g = \sum_{\text{ground}} U A\)
   - For each `adj_k`, accumulate \(H_{z \leftrightarrow ztu_k} = \sum_{s \in S_{z \leftrightarrow ztu_k}} U_s A_s\)
2. For each unconditioned zone `adj_k`:
   - From its arrays, compute \(H^{\mathrm{tr}}_{ztu_k\to e} = \sum U A\) for elements not facing the main zone (if you don’t list facing elements, treat all as external/ground of that unconditioned space).
   - Choose \(n_{ue}\) from `df_n_ue` table; default \(n_{ue}=0.5\) h⁻¹.
   - Compute \(H^{\mathrm{ve}}_{ztu_k\to e} = 0.33 V_{ztu_k} n_{ue}\).
   - \(H_{ztu_k\to e} = H^{\mathrm{tr}}_{ztu_k\to e} + H^{\mathrm{ve}}_{ztu_k\to e}\).
   - Monthly adjustment \(b_{ztu_k,m} = \dfrac{H_{ztu_k\to e}}{H_{ztu_k\to e}+H_{z \leftrightarrow ztu_k}}\).

**Hourly loop:**
1. Compute \(H^{\mathrm{ve}}_z(t)\) from ISO 16798-7 §6 using wind/stack (or simplified occupancy mode).
2. Compute \(\Phi^{\mathrm{int}}_z(t)\) from profiles (§7) and optional redistribution (7.2).
3. Compute solar gains \(\Phi^{\mathrm{sol}}_z(t)\) from §9 (transparent elements + shading).
4. Build \(H^{\mathrm{eff}}_{z\to e,m} = H_{z\to e} + \sum_j (1-b_j)H_{z\leftrightarrow j} + H_g + H^{\mathrm{ve}}_z(t)\).
5. Advance \(\theta_z^{n+1}\) via (5.2). Apply setpoint control to derive \(\Phi^{\mathrm{sys}}_z\) (bounded by capacities).

---

## 11. Worked Mapping for Your Example `BUI`

**Given:**  
- Interfaces to unconditioned:  
  - North opaque: \(U=1.4, A=30 \Rightarrow H_{z\leftrightarrow adj_1}=42\) W/K  
  - South opaque: \(U=1.4, A=30 \Rightarrow H_{z\leftrightarrow adj_2}=42\) W/K
- External opaque/roof:  
  - East \(1.2\times 30 = 36\) W/K, West \(=36\) W/K, Roof \(2.2\times 130=286\) W/K
- Ground: slab \(1.6\times 100=160\) W/K
- Unconditioned zones: \(V=300\) m³ each, default \(n_{ue}=0.5\) h⁻¹ → \(H^{\mathrm{ve}}_{ztu\to e}=0.33\cdot 300\cdot 0.5=49.5\) W/K

**Per unconditioned zone \(k\):**
- If (conservatively) you treat the whole unconditioned envelope as external/ground for \(H^{\mathrm{tr}}_{ztu\to e}\), add it using its arrays. If you lack the split, you can start with **0** to estimate a lower bound.
- Monthly factor:
```math
b_{\mathrm{adj}_k,m} = \frac{H_{ztu_k\to e}}{H_{ztu_k\to e} + 42}
\tag{11.1}
```
- Effective exterior conductance:
```math
H^{\mathrm{eff}}_{z\to e,m} = (36+36+286) + \sum_k (1-b_{\mathrm{adj}_k,m})\cdot 42 + 160 + H^{\mathrm{ve}}_z(t)
\tag{11.2}
```

**Ventilation (two windows, east/west):**  
Heights \(h_w=2\) m, widths \(w=1\) m → geometric area 2 m² each; if `Rw=0.9`, per window effective opening \(=1.8\) m² → \(A_w^{\mathrm{tot}}=3.6\) m².  
Parapet = 1.1 m → from (6.1–6.2) get \(h_w^{\mathrm{st}}\) (typically ≈ window height if identical openings).  
Use (6.5–6.6) with \(u_{\mathrm{site}}, θ_z, θ_e\) to get \(H^{\mathrm{ve}}_z\).

---

## 12. Function-by-Function Mapping

### 12.1 `ventilation.py::heat_transfer_coefficient_by_ventilation(...)`
- Implements (6.1)–(6.6)/(6.7).  
- **Inputs**: `Tz, Te, u_site, Rw_arg_i, altitude, type_ventilation` and `BUI["building_surface"]`.  
- **Outputs**: `H_ve_nat` (W/K).  
- **Pitfalls**: make sure arrays of window geometry exist; default opening ratio \(R_w=0.9\) if `Rw_arg_i` missing.

### 12.2 `ventilation.py::internal_gains(...)`
- Implements (7.1) and optionally (7.2) if redistribution is used.  
- **Inputs**: `building_type_class`, `a_use`, hourly multipliers (`h_occup`, `h_app`, `h_light`, ...).  
- **Output**: `Phi_int` (W).

### 12.3 `ventilation.py::transmission_heat_transfer_coefficient_ISO13789(...)`
- Implements (4.3)–(4.5) and builds \(H_{ztu\to e}\), \(b_{ztu,m}\).  
- **Inputs**: one adjacent zone object (or references to main & adj envelope partitions), `n_ue` (default 0.5 h⁻¹), optional `q_iu` (default 0).  
- **Outputs**: `(H_ztu_tot, b_ztu_m)`; use \(b\) inside the main-zone balance (5.1).

### 12.4 `generate_profile.py::HourlyProfileGenerator`
- Builds hourly calendar and maps category profiles per (8.1).  
- Provides plotting for QA; not required for core physics.

---

## 13. Numerical Checklist (What to Log Per Hour)

- `H_z->e`, `H_g`, `H_z<->ztu[k]` (static)
- `H_ztu->e[k]`, `b[k]` (monthly/static unless n_ue varies by month)
- `H_ve_z(t)` from (6.5/6.7)
- `Φ_int_z(t)` from (7.1)
- `Φ_sol_z(t)` from (9.1)
- `H_eff(t)` from (5.1) components
- `θ_z(t+1)` from (5.2), `Φ_sys_z(t)` from setpoint/capacity

---

## 14. References

- ISO 52016-1:2017, ISO 52010-1:2017
- ISO 13789:2017
- ISO 16798-1:2019, ISO 16798-7:2017

---

## 15. Minimal Example Code Snippets

**Ventilation (single-sided):**
```python
Hve = heat_transfer_coefficient_by_ventilation(
    building_object=BUI,
    Tz=20.0, Te=10.0, u_site=2.5,
    Rw_arg_i=None, altitude=300.0, type_ventilation="temp_wind"
)
```

**Internal gains (occupants + appliances with profiles):**
```python
Phi_int = VentilationInternalGains.internal_gains(
    building_type_class=BUI["building"]["building_type_class"],
    a_use=BUI["building"]["net_floor_area"],
    h_occup=profile_df.loc[t, "occupancy_profile"],
    h_app=profile_df.loc[t, "appliances_profile"],
    h_light=profile_df.loc[t, "lighting_profile"]
)
```

**Coupling to unconditioned zone (monthly):**
```python
H_ztu_tot, b_ztu = transmission_heat_transfer_coefficient_ISO13789(
    adj_zone=BUI["adjacent_zones"][0], n_ue=0.5, qui=0
)
# contribution → (1 - b_ztu) * H_z_to_ztu added to exterior side
```

---

## 16. QA Notes

- Validate that the sum of surface areas roughly matches `net_floor_area` perimeter/height expectations.
- For windows: ensure `height`, `width`, `parapet` exist; if not, set defensible defaults and warn.
- If you don’t have ISO 13370 ground calc, be explicit that `H_g` is simplified. -->

# ISO 52010/52016 Building Simulation – Module-level Technical Notes

> Scope: this document is **strictly focused on the existing modules** and the current data structure you shared:
> - `global_inputs.py`
> - `generate_profile.py`
> - `ventilation.py`
> - Input schema `BUI` (Python dict)

It explains each function’s purpose, physics, inputs/outputs, algorithmic flow, and edge cases. All equations use SI unless otherwise stated.

---

## 1) Input Schema — `BUI` (data contract)

This dictionary is the canonical input. It provides:
- **Site** (lat/lon, azimuth), **morphology** (perimeter, height, thickness), **program** (type class), **adjacent zones**, **surfaces**, and **system/profiles**.

### 1.1 Semantics (selected keys)

- `building.azimuth_relative_to_true_north` `[deg]`: clockwise from true North (0=N, 90=E).
- `building.exposed_perimeter` `[m]`: used in some ISO ground/perimeter correlations.
- `building.wall_thickness` `[m]`: wall layer total thickness (used e.g. for geometric checks / future U recalcs).
- `building.adj_zones_present` `[bool]`: master switch for unconditioned / adjacent zones coupling.
- `adjacent_zones[*].orientation_zone.azimuth` `[deg]`: local azimuth of each adjacent unconditioned zone.
- `adjacent_zones[*].area_facade_elements` `[m²]`: areas per element (vector aligned with `typology_elements` and `orientation_elements`).
- `adjacent_zones[*].typology_elements`: element types:
  - `OP` = opaque envelope element,
  - `GR` = ground-coupled,  
  (extendable: `TR` windows, etc., if needed in future).
- `adjacent_zones[*].transmittance_U_elements` `[W·m⁻²·K⁻¹]`: U by element, 1:1 with areas.
- `adjacent_zones[*].orientation_elements`: orientation code by element:
  - `NV` North-vertical (≈0°), `SV` South-vertical (≈180°),
  - `EV` East-vertical (≈90°),  `WV` West-vertical (≈270°),
  - `HOR` horizontal (roof/slab).
- `adjacent_zones[*].volume` `[m³]`: air volume of unconditioned zone (used for air change calc).
- `adjacent_zones[*].a_use` `[m²]`: useful area of the adjacent zone (for internal gains split).
- `building_surface[*]`: explicit building surfaces (opaque + transparent), with:
  - `u_value` `[W·m⁻²·K⁻¹]`, `g_value` (for transparent), `solar_absorptance` `[-]`,
  - `orientation` (`azimuth` `[deg]`, `tilt` `[deg]`),
  - **optional** `name_adj_zone` to bind a surface to a specific unconditioned adjacent zone name.
- `building_parameters.*`: setpoints, capacities, airflow rates (ACH), internal gains profiles, and ON/OFF schedules.

> **Note**: The current modules consume only a subset (ventilation, internal gains, adjacent zone transmission). The fields are intentionally richer to allow later coupling with ISO 52010 solar/sky and ISO 52016 balance.

---

## 2) `global_inputs.py` — Static data & constants

### 2.1 Purpose
- Provide **reference tables** (e.g., ISO 13789 `n_ue` air-tightness classes) and **thermophysical constants**.
- Contain an **emitter table** `TB14` (ΔT exponents).

### 2.2 Key Objects

- `periods`, `bui_types`, `months`: taxonomies.
- `WATER_DENSITY = 1000` `[kg·m⁻³]`
- `WATER_SPECIFIC_HEAT_CAPACITY = 0.00116` `[kWh·kg⁻¹·K⁻¹]` (→ multiply by `kg` and `ΔT` to get kWh)
- `df_n_ue` — ISO 13789:2018 (Table 7) **conventional air change rate** between unconditioned space and exterior:

| code | description (air-tightness) | `n_ue` [h⁻¹] |
|------|-----------------------------|--------------|
| 1 | No doors/windows openings | 0.1 |
| 2 | All joints well sealed, no openings | 0.5 |
| 3 | Well sealed, small openings | 1.0 |
| 4 | Some localized open joints | 3.0 |
| 5 | Numerous open joints / large openings | 10.0 |

- `TB14` — emitter exponents and nominal ΔT:
  - Radiator: `n=1.3`, `Δθ_air=50°C`, `Δθ_water=20°C`
  - Floor heating: `n=1.1`, `Δθ_air=15°C`, `Δθ_water=5°C`
  - Fan coil: `n=1.0`, `Δθ_air=25°C`, `Δθ_water=10°C`

### 2.3 Usage & Physics
- `n_ue` maps directly into **adjacent unconditioned zone ventilation** (see §4.3), i.e. `que = V_u · n_ue` `[m³·h⁻¹]`.
- Water constants are useful for DHW/emitters energy conversions (not used inside `ventilation.py` yet).

---

## 3) `generate_profile.py` — Hourly operational profiles

### 3.1 Purpose
Generate a **13-month** hourly DataFrame with working/holiday flags and per-category profiles:
`{ventilation, heating, cooling, occupancy, lighting, appliances}`.

### 3.2 Public API

#### Class
```python
class HourlyProfileGenerator:
    def __init__(country='IT', num_months=13, start_year=None,
                 working_day_profile=None, holiday_profile=None,
                 category_profiles=None)
```

#### Methods
- `generate() -> pd.DataFrame`
- `get_summary() -> None`
- `plot_annual_profiles(categories=None, freq="H", include_weekend_shading=True, title="...") -> plotly.graph_objects.Figure`

### 3.3 Physics & Semantics
- Profiles are **dimensionless multipliers** in `[0,1]` applied to full-load densities (e.g., W·m⁻² or l·s⁻¹·m⁻²) to produce hour-by-hour loads/flows.  
- **Holidays** via `holidays` lib using `country` 2-letter code; **weekends** = Sat/Sun.

### 3.4 Normalization Rules
Each category `c` stores two 24-length arrays:
- `c_profile` on **weekday** vs **holiday/weekend**.
- Given an hour `h`, final profile value is:
\[
p_c(h, d) =
\begin{cases}
p_{c,\mathrm{wd}}(h), & \text{if } d \text{ is a working day}\\
p_{c,\mathrm{hd}}(h), & \text{if } d \text{ is holiday/weekend}
\end{cases}
\tag{3.1}
\]

### 3.5 Outputs
`generate()` returns a DataFrame with:
- time columns: `datetime`, `date`, `hour`, `day_of_week`, `day_name`
- flags: `is_holiday`, `is_weekend`, `is_working_day`, `holiday_name`
- per-category: `ventilation_profile`, `heating_profile`, …, `appliances_profile`
- legacy: `profile_value` (alias of `occupancy_profile`), `day_type`

### 3.6 Edge Cases
- If `category_profiles` is missing a key, defaults are **copied** from `working_day_profile` / `holiday_profile` (or built-in defaults).
- Input validation enforces 24-length arrays.

---

## 4) `ventilation.py` — Ventilation conductance, internal gains, and ISO 13789 adjacent-zone coupling

### 4.1 Data classes

```python
@dataclass
class h_natural_vent:
    H_ve_nat: np.ndarray
```
Currently a thin container (kept for future interface symmetry).

---

### 4.2 `heat_transfer_coefficient_by_ventilation(...)`  
**Physical purpose**: compute the **ventilation heat transfer coefficient** \(H_{ve}\) `[W·K⁻¹]` of the thermal zone either:
- from **natural ventilation** (ISO 16798-7:2017, single-sided airing via windows, wind/stack), or
- from **occupancy-driven flow** (simplified volumetric rate per floor area).

#### Signature
```python
@staticmethod
def heat_transfer_coefficient_by_ventilation(
    building_object, Tz, Te, u_site, Rw_arg_i=None, c_air=1006, 
    rho_air=1.204, C_wnd=0.001, C_st=0.0035, rho_a_ref=1.204, altitude=None,
    type_ventilation="temp_wind", flowrate_person=1.4
) -> h_natural_vent:
```

#### Inputs (main)
- `Tz` `[°C]` indoor air temperature (zone).
- `Te` `[°C]` outdoor air temperature.
- `u_site` `[m·s⁻¹]` local wind speed at site height (as per ISO 16798-7 assumptions).
- `Rw_arg_i` `[-]` array of **opening ratios** per window (`0…1`). If `None`, defaults to `0.9`.
- `C_wnd = 0.001` `[(m·s⁻¹)⁻¹]` wind coefficient (ISO 16798-7 Table 11).
- `C_st = 0.0035` `[(m·s⁻¹)/(m·K)]` stack coefficient (ISO 16798-7 Table 11).
- `rho_a_ref` `[kg·m⁻³]` reference air density at ~20 °C; corrected with `altitude` if provided.
- `type_ventilation`: `"temp_wind"` (ISO airing) or `"occupancy"` (area-based volumetric rule).
- `flowrate_person` `[L·s⁻¹·m⁻²]` used only in `"occupancy"` branch.

#### Physics

**Step A — Effective opening height (stack path)**  
For each transparent surface:
- parapet height \(h_p\) `[m]`,  
- window height \(h_w\) `[m]`,  
- **path height** (vertical center): \(h_{path,i} = h_p + \frac{h_w}{2}\),
- **fa height**: \(h_{fa,i} = \frac{h_w}{2}\).

The **useful stack height**:
\[
h_{w,st} = \max_i\!\left(h_{path,i} + \frac{h_{fa,i}}{2}\right) - \min_i\!\left(h_{path,i} - \frac{h_{fa,i}}{2}\right)
\tag{4.1}
\]

**Step B — Density correction**  
If `altitude` present, a standard atmosphere relation updates \(\rho_{a,ref}\). Outdoor density:
\[
\rho_{a,e} = \rho_{a,ref}\,\frac{291.15}{273.15 + T_e}
\tag{4.2}
\]

**Step C — Effective openable area**  
For each window \(i\), geometric area \(A_{w,i} = h_{w,i}\,w_i\).  
Open area \(A_{w,i}^{open} = A_{w,i}\,R_{w,i}\) with \(R_{w,i}\in[0,1]\).
If `Rw_arg_i` is missing or length mismatches the number of windows, default \(R_{w,i}=0.9\).
\[
A_{w,tot} = \sum_i A_{w,i}^{open}
\tag{4.3}
\]

**Step D — Airing volumetric flow (single-sided)**  
Using ISO 16798-7 §6.4.3.5.4:
\[
q_v = 3600\;\frac{\rho_{a,ref}}{\rho_{a,e}}\;\frac{A_{w,tot}}{2}\,
\left[\max\!\Big(C_{wnd}\,u_{site}^2,\; C_{st}\,h_{w,st}\,\lvert T_z-T_e\rvert\Big)\right]^{1/2}
\quad [\text{m}^3/\text{h}]
\tag{4.4}
\]

**Step E — Ventilation conductance**
\[
H_{ve} = \frac{c_{air}\,\rho_{air}}{3600}\;q_v
\quad [\text{W·K}^{-1}]
\tag{4.5}
\]

**Occupancy branch**: area-based simplified rule (constant per hour)
\[
H_{ve} = A_{use}\cdot (3.6\,\dot v_{pers})\cdot \frac{c_{air}\,\rho_{air}}{3600}
\tag{4.6}
\]
with \(\dot v_{pers}\) in `[L·s⁻¹·m⁻²]` and `3.6` converting L·s⁻¹·m⁻² to m³·h⁻¹·m⁻².

#### Outputs
- `np.ndarray` of `H_ve_k_t` `[W·K⁻¹]` (scalar or time-series depending on inputs).

#### Algorithm (pseudo)
```python
if type_ventilation == "temp_wind":
    extract all windows -> {height, width, parapet}
    compute hw_path_i, hw_fa_i -> hw_st  # Eq. (4.1)
    density correction -> rho_a_e        # Eq. (4.2)
    aw_tot -> Eq. (4.3)
    qv -> Eq. (4.4)
    Hve -> Eq. (4.5)
else:  # occupancy
    A_use <- building_object["building"]["net_floor_area"]
    Hve  <- Eq. (4.6)
return np.array(Hve)
```

#### Edge Cases & Validation
- No transparent surfaces → \(A_{w,tot}=0\) → \(H_{ve}=0\).
- `Rw_arg_i` length mismatch → warning + default 0.9.
- Negative or null `u_site` accepted; `max(·)` ensures stack/wind pick the dominant driver.

---

### 4.3 `internal_gains(...)`  
**Physical purpose**: compute **internal sensible gains** \(\Phi_{int}\) `[W]` in the **thermally conditioned zone**, possibly accounting for **spillover** to adjacent unconditioned zones.

#### Signature
```python
def internal_gains(
    cls, building_type_class, a_use, unconditioned_zones_nearby=False,
    list_adj_zones=None, Fztc_ztu_m: float=1, b_ztu: float=1,
    h_occup: float=1, h_app: float=1, h_light: float=1, h_dhw: float=1,
    h_hvac: float=1, h_proc: float=1
) -> float:
```

#### Inputs (main)
- `building_type_class`: key for the lookup table `internal_gains_occupants` (imported from `source.table_iso_16798_1`).
- `a_use` `[m²]`: useful area of the **conditioned** zone.
- `h_*` `[-]`: hourly multipliers (profiles) for each sub-component (currently **occupants** and **appliances** are used).
- Coupling params for unconditioned zones:
  - `b_ztu` `[-]`: **adjustment factor** of the adjacent unconditioned zone (see §4.4, Eq. (4.13)).
  - `Fztc_ztu_m` `[-]`: **fractional path factor** conditioned→unconditioned in month `m` (lumped path coefficient).
  - `list_adj_zones`: **number** of adjacent zones (note: the current signature expects an **int**; see note below).

> **Note**: The code uses `for zones in range(list_adj_zones)` — pass an `int`. If a list is desired in the future, change to `for z in list_adj_zones:`.

#### Physics
Let \(q_{occ}\) and \(q_{app}\) be the nominal **density** of internal gains `[W·m⁻²]` for occupants/equipment per `building_type_class`.

**Base internal gains** in the **conditioned zone**:
\[
\Phi_{int,z}(t) = \big(q_{occ}\,h_{occup}(t) + q_{app}\,h_{app}(t)\big)\;A_{use}
\tag{4.7}
\]

**Optional spillover** to **unconditioned** adjacent zones (`unconditioned_zones_nearby = True`):  
The code currently **adds** a further term per adjacent zone combining a **direct duplicated** contribution and a **fractional transfer** modulated by \((1-b_{ztu})\,F_{ztc{\text -}ztu,m}\):
\[
\Phi_{int,z}^{eff}(t)
= \Phi_{int,z}(t) + \sum_{j=1}^{N_{adj}}
\left[\Phi_{int,z}(t) + \big(1-b_{ztu}\big)\,F_{ztc{\text -}ztu,m}\,\Phi_{int,z}(t)\right]
\tag{4.8}
\]

> **Remark**: Eq. (4.8) mirrors the present implementation logic. In a thermodynamic sense, one might prefer **partitioning** \(\Phi_{int}\) (instead of adding duplicates) across coupling paths; if you intend to conserve energy strictly, revisit this formulation.

#### Output
- `float` `[W]` — instantaneous internal sensible gains for the conditioned zone with the current coupling rule.

#### Algorithm (pseudo)
```python
q_occ = internal_gains_occupants[building_type_class]['occupants']
q_app = internal_gains_occupants[building_type_class]['appliances']
Phi_base = (q_occ*h_occup + q_app*h_app) * a_use        # Eq. (4.7)
if unconditioned_zones_nearby:
    Phi_eff = Phi_base
    for _ in range(list_adj_zones):
        Phi_eff += Phi_base + (1-b_ztu)*Fztc_ztu_m * Phi_base
    return float(Phi_eff)
else:
    return float(Phi_base)
```

---

### 4.4 `transmission_heat_transfer_coefficient_ISO13789(...)`  
**Physical purpose**: compute **transmission coupling** between a **thermally conditioned** zone (ztc) and **adjacent unconditioned** zone(s) (ztu) per ISO 13789, including the **ventilation of the unconditioned** zone to the outside.

> **Important**: In the snippet, `building_object`, `orient_all_zones`, and `volume_all_zones` are referenced but **not passed**. In practice you should pass the **adjacent zone object** (or the whole `BUI`) and extract what you need locally. The equations below describe the intended physics.

#### Signature (as provided)
```python
def transmission_heat_transfer_coefficient_ISO13789(adj_zone, n_ue=0.5, qui=0):
    ...
    return H_ztu_tot, b_ztu_m
```

#### Concepts & Notation
- \(H_{tr}\) is decomposed as:
\[
H_{tr} = H_d + H_g + H_u + H_a
\tag{4.9}
\]
with:
- \(H_d\): direct envelope transmission to **exterior**,
- \(H_g\): ground transmission,
- \(H_u\): via **unconditioned** space,
- \(H_a\): to **adjacent buildings** (not used here).

#### Step 1 — Transmission **conditioned → unconditioned**
For the **interface** between ztc and ztu:
\[
H_{d,zt{\text -}ztu} = \sum_{k \in\mathcal{E}_{zt{\text -}ztu}} U_k\,A_k
\tag{4.10}
\]
where the set \(\mathcal{E}_{zt{\text -}ztu}\) are elements on the **shared** boundary.

#### Step 2 — Transmission **unconditioned → exterior**
For ztu walls not shared with ztc (i.e., exposed or to other media):
\[
H_{d,ztu{\text -}ext} = \sum_{k \in\mathcal{E}_{ztu{\text -}ext}} U_k\,A_k
\tag{4.11}
\]

#### Step 3 — **Ventilation** of unconditioned zone
ISO 13789 suggests using **air change rate** \(n_{ue}\) `[h⁻¹]` for ztu → outside.  
Let \(V_u\) `[m³]` be ztu air volume. Define:
\[
q_{ue} = V_u\,n_{ue} \quad [\text{m}^3/\text{h}], \qquad
q_{iu} = q_{i\to u} \quad [\text{m}^3/\text{h}] \text{ (often set to 0 to avoid overestimation)}
\tag{4.12a}
\]
Use the standard \(\rho c\) factor \(\approx 0.33\) `[Wh·m⁻³·K⁻¹]` for flows expressed in m³·h⁻¹:
\[
H_{ve,ue} = 0.33\,q_{ue}, \qquad H_{ve,iu} = 0.33\,q_{iu}
\tag{4.12b}
\]
By **default** in the code: \(q_{iu} = 0\).

#### Step 4 — Aggregate coupling terms
\[
H_{ue} = H_{d,ztu{\text -}ext} + H_{ve,ue}, \qquad
H_{iu} = H_{d,zt{\text -}ztu} + H_{ve,iu}
\tag{4.12c}
\]
Total **ztu coupling**:
\[
H_{ztu,tot} = H_{iu} + H_{ue}
\tag{4.12d}
\]

**Adjustment factor** \(b_{ztu,m}\) (ISO 13789 monthly convention):
\[
b_{ztu,m} = \frac{H_{ue}}{H_{ue} + H_{iu}} = \frac{H_{ue}}{H_{ztu,tot}}
\tag{4.13}
\]
\(b_{ztu,m}\in[0,1]\) measures how much the unconditioned zone is “anchored” to the **outside** rather than to the **conditioned** neighbor.

#### Output
- `H_ztu_tot` `[W·K⁻¹]` — total coupling of the unconditioned zone.
- `b_ztu_m` `[-]` — monthly factor (in the current code computed once from static inputs).

#### Practical extraction with your `BUI` structure
- For **a given unconditioned zone** `adj_i`:
  - Build sets:
    - \(\mathcal{E}_{zt{\text -}ztu}\): elements in `adj_i` whose `orientation_elements` **match** the interface direction to the conditioned zone (your code uses equality tests by `NV/SV/EV/WV/HOR`).
    - \(\mathcal{E}_{ztu{\text -}ext}\): elements in `adj_i` **not** on the interface.
  - Use `adj_i.volume` → \(V_u\).  
  - Pick `n_ue` from `df_n_ue` by air-tightness class or keep default `0.5 h⁻¹`.

#### Algorithm (pseudo; robust version)
```python
def transmission_heat_transfer_coefficient_ISO13789(BUI, adj_zone_name, n_ue=0.5, qui=0):
    adj = get_adj_zone(BUI, adj_zone_name)
    A = np.asarray(adj["area_facade_elements"], dtype=float)
    U = np.asarray(adj["transmittance_U_elements"], dtype=float)
    ORI = np.asarray(adj["orientation_elements"])
    # Define which orientations correspond to zt-ztu interface (project specific rule):
    mask_interface = is_interface_to_conditioned_zone(ORI, adj, BUI)   # boolean mask
    Hd_zt_ztu  = float(np.sum(A[mask_interface] * U[mask_interface]))   # Eq. (4.10)
    Hd_ztu_ext = float(np.sum(A[~mask_interface] * U[~mask_interface])) # Eq. (4.11)

    # Ventilation terms (Eq. 4.12)
    Vu = float(adj["volume"])
    que = Vu * n_ue
    Hve_ue = 0.33 * que
    Hve_iu = 0.33 * float(qui)

    Hue = Hd_ztu_ext + Hve_ue
    Hiu = Hd_zt_ztu + Hve_iu
    Hztu_tot = Hue + Hiu                                 # Eq. (4.12d)
    b_ztu_m  = Hue / Hztu_tot if Hztu_tot > 0 else 1.0   # Eq. (4.13)
    return float(Hztu_tot), float(b_ztu_m)
```

#### Edge Cases
- If `A`/`U` vectors contain **dtype=object** (as in your snippet), cast explicitly to `float`.
- If `Hztu_tot = 0` (degenerate geometry), define `b_ztu_m = 1.0` by convention (fully outdoor-anchored).

---

## 5) Multizone & Adjacent-Zone Coupling — Computational Flow

```mermaid
graph TD
  A[BUI dict] --> B(global_inputs.py)
  A --> C(generate_profile.py)
  A --> D(ventilation.py)

  C --> C1[Hourly profiles h_* (0..1)]
  B --> D1[df_n_ue, constants]
  D1 --> D3
  C1 --> D2

  subgraph Ventilation & Gains (ventilation.py)
    D2[heat_transfer_coefficient_by_ventilation]\nH_ve via ISO 16798-7 or occupancy
    D3[transmission_heat_transfer_coefficient_ISO13789]\nH_ztu_tot, b_ztu_m
    D4[internal_gains]\nPhi_int with optional adj-zone spillover
  end

  D2 --> E[H_ve (W/K)]
  D3 --> F[b_ztu_m (-)]
  D4 --> G[Phi_int (W)]

  %% (Future) Energy balance solver (not in scope here)
  E --> H[(Future: ISO 52016 solver)]
  F --> H
  G --> H
```

---

## 6) Variable Glossary (selected)

| Symbol / Name | Meaning | Units |
|---|---|---|
| \(T_z\), `Tz` | Zone air temperature (indoor) | °C |
| \(T_e\), `Te` | Outdoor air temperature | °C |
| \(u_{site}\) | Site wind speed at window height (per ISO assumptions) | m·s⁻¹ |
| \(h_p\) | Parapet height | m |
| \(h_w\) | Window height | m |
| \(h_{path}\) | Window vertical center above floor | m |
| \(h_{w,st}\) | Useful stack height for airing | m |
| \(A_{w,i}\) | Geometric area of window \(i\) | m² |
| \(R_{w,i}\) | Opening ratio window \(i\) | – |
| \(A_{w,tot}\) | Sum of openable window areas | m² |
| \(\rho_{a,ref}\) | Reference indoor air density | kg·m⁻³ |
| \(\rho_{a,e}\) | Outdoor density at \(T_e\) | kg·m⁻³ |
| \(q_v\) | Airing volumetric flow (single-sided) | m³·h⁻¹ |
| \(H_{ve}\) | Ventilation heat transfer coefficient | W·K⁻¹ |
| \(U_k\) | Thermal transmittance of element \(k\) | W·m⁻²·K⁻¹ |
| \(V_u\) | Air volume of unconditioned zone | m³ |
| \(n_{ue}\) | Air change rate ztu–exterior | h⁻¹ |
| \(q_{ue}\) | Flow ztu–exterior \(=V_u n_{ue}\) | m³·h⁻¹ |
| \(H_{ve,ue}\) | Vent. conductance ztu–exterior | W·K⁻¹ |
| \(H_{d,zt{\text -}ztu}\) | Transmission cond→uncond | W·K⁻¹ |
| \(H_{d,ztu{\text -}ext}\) | Transmission uncond→ext | W·K⁻¹ |
| \(H_{ztu,tot}\) | Total ztu coupling | W·K⁻¹ |
| \(b_{ztu,m}\) | Adjustment factor of ztu | – |
| \(\Phi_{int}\) | Internal gains (sensible) | W |
| \(q_{occ}, q_{app}\) | Gains densities (occ/app) | W·m⁻² |

---

## 7) Implementation Notes & Robustness

- **Type safety**: many arrays in `BUI` are `dtype=object`. Cast to `np.asarray(..., dtype=float)` before algebra.
- **Orientation logic**: To identify interface elements for \(H_{d,zt{\text -}ztu}\), define a **clear mapping** between `building_surface[*].name_adj_zone` and the `adjacent_zones[*].name` and use that to split \(\mathcal{E}_{zt{\text -}ztu}\) vs \(\mathcal{E}_{ztu{\text -}ext}\). Avoid relying only on cardinal labels like `NV/SV/...` when adjacency is explicit in the `BUI`.
- **Energy conservation**: The current `internal_gains` implementation **adds** spillover per adjacent zone. If you need strict conservation, change Eq. (4.8) to a **partitioning** where the sum of delivered gains across all coupled domains equals the source generation.
- **Units consistency**: Eq. (4.12b) uses the common shortcut `0.33` `[Wh·m⁻³·K⁻¹]` for flows in m³·h⁻¹. If you operate on SI `[s]`, convert accordingly \( \frac{\rho c}{3600} \).
- **Altitude**: The simple density correction used in Eq. (4.2) is adequate for building simulation. For high-altitude sites you may want a full barometric formula.

---

## 8) Worked Example Hooks (with your `BUI`)

Below is a minimal sketch showing how to call the three core functions **consistently** with your schema.

```python
# Pseudocode (assumes the functions accept BUI as 'building_object')
from ventilation import VentilationInternalGains, transmission_heat_transfer_coefficient_ISO13789

# --- Ventilation H_ve (ISO airing)
Tz = 20.0   # °C
Te = 5.0    # °C
u  = 2.5    # m/s
Hve = VentilationInternalGains.heat_transfer_coefficient_by_ventilation(
    building_object=BUI, Tz=Tz, Te=Te, u_site=u, type_ventilation="temp_wind"
)

# --- Internal gains (W)
Phi_int = VentilationInternalGains.internal_gains(
    building_type_class=BUI["building"]["building_type_class"],
    a_use=BUI["building"]["net_floor_area"],
    unconditioned_zones_nearby=True,
    list_adj_zones=len(BUI["adjacent_zones"]),   # pass an int here
    Fztc_ztu_m=1.0,
    b_ztu=0.6,
    h_occup=0.8, h_app=0.6
)

# --- Adjacent zone coupling (W/K) for 'adj_1'
Hztu_tot_1, b_ztu_1 = transmission_heat_transfer_coefficient_ISO13789(
    adj_zone=BUI["adjacent_zones"][0],  # or pass BUI + name, per your refactor
    n_ue=0.5, qui=0.0
)
```

---

## 9) Testing Checklist

- **No windows** → `H_ve=0` (temp_wind branch).
- **All `Rw_arg_i=0`** → `H_ve=0`.
- **High wind, small ΔT** vs **low wind, high ΔT** → Eq. (4.4) switches between wind/stack terms.
- **`n_ue` sweep** (0.1 → 10 h⁻¹) increases \(H_{ve,ue}\) linearly, thus \(b_{ztu,m}\) approaches 1.
- **`qui>0`** lifts \(H_{iu}\), thus \(b_{ztu,m}\downarrow\).
- **Profiles**: Verify daily cycles in `generate_profile.py` and holiday flips.

---

## 10) Known Gaps (future improvements)

- **Window cross-ventilation** and **leakage** paths in `ventilation.py` (not yet implemented).
- **Mechanical ventilation** (specific supply/exhaust flow schedule) placeholder.
- **Transparent interface terms** in `ISO13789` when the partition is glazed.
- **Time-varying** \(b_{ztu,m}\) (currently returned as a scalar unless you process it per month).
